# Operacje geometryczne{#geometry-operations}

```{r, include=FALSE}
source("code/before_script.R")
```

## Wymagania wstępne{-}

- W niniejszym rozdziale wykorzystano te same pakiety, co w rozdziale @ref(spatial-operations),ale z dodatkiem**spDataLarge**, który został zainstalowany w rozdziale @ref(spatial-class):

```{r 05-geometry-operations-1, message=FALSE}
library(sf)
library(terra)
library(dplyr)
library(spData)
library(spDataLarge)
```

## Wprowadzenie

Do tej pory w książce wyjaśniono strukturę zbiorów danych geograficznych (rozdział @ref(spatial-class)) oraz sposoby manipulowania nimi w oparciu o ich atrybuty niegeograficzne (rozdział @ref(attr)) i relacje przestrzenne (rozdział @ref(spatial-operations)).
W niniejszym rozdziale skupiono się na manipulowaniu elementami geograficznymi obiektów przestrzennych, na przykład poprzez tworzenie buforów, upraszczanie i konwertowanie geometrii wektorowych oraz agregowanie i ponowne próbkowanie danych rastrowych.
Po przeczytaniu tego rozdziału i wykonaniu ćwiczeń zamieszczonych na końcu, czytelnik powinien zrozumieć i opanować obsługę kolumny geometrii w`sf`obiektach oraz zasięg i położenie geograficzne pikseli reprezentowanych w rasterach w odniesieniu do innych obiektów geograficznych.

Sekcja @ref(geo-vec) obejmuje transformację geometrii wektorowych za pomocą operacji „jednoargumentowych” i „dwuargumentowych”.Operacje
jednoargumentowe działają na pojedynczej geometrii w izolacji, w tym uproszczenie (linii i wielokątów), tworzenie buforów i centroidów oraz przesuwanie/skalowanie/obracanie pojedynczych geometrii za pomocą „transformacji afinicznych” (sekcje @ref(simplification) do @ref(affine-transformations)).
Transformacje binarne modyfikują jedną geometrię na podstawie kształtu innej, w tym przycinanie i połączenia geometrii\\index{vector!union}, omówione w sekcjach @ref(clipping) do @ref(geometry-unions).
Transformacje typu (na przykład z wielokąta do linii) są przedstawione w sekcji @ref(type-trans).

Sekcja @ref(geo-ras) dotyczy transformacji geometrycznych obiektów rastrowych.
Obejmuje to zmianę rozmiaru i liczby pikseli bazowych oraz przypisanie im nowych wartości.
Pokazuje, jak zmienić rozdzielczość (zwaną również agregacją i dezagregacją rastra), zasięg i punkt początkowy rastra.Operacje
te są szczególnie przydatne, jeśli chce się wyrównać zestawy danych rastrowych z różnych źródeł.
Wyrównane obiekty rastrowe mają zgodność jeden do jednego między pikselami, co pozwala na ich przetwarzanie za pomocą operacji algebry map, opisanych w sekcji @ref(map-algebra).

Interakcja między obiektami rastrowymi i wektorowymi została omówiona w rozdziale @ref(raster-vector).
Przedstawiono w nim, w jaki sposób wartości rastrowe mogą być „maskowane” i „ekstrahowane” przez geometrie wektorowe.
Co ważne, pokazuje również, jak „poligonizować” rastrowe i „rasteryzować” wektorowe zbiory danych, dzięki czemu te dwa modele danych stają się bardziej wymienne.

## Operacje geometryczne na danych{#geo-vec}wektorowych

Ta sekcja dotyczy operacji, które w jakiś sposób zmieniają geometrięobiektówwektorowych (`sf`).Jest
to bardziej zaawansowane niż operacje na danych przestrzennych przedstawione w poprzednim rozdziale (sekcja @ref(spatial-vec)), ponieważ tutaj zagłębiamy się w geometrię:
funkcje omówione w tej sekcji działają na obiektach klasy`sfc`oprócz obiektów klasy`sf`.

### Uproszczenie

\\index{vector!simplification}
Uproszczenie to proces uogólniania obiektów wektorowych (linii i wielokątów), zwykle w celu wykorzystania ich na mapach o mniejszej skali.
Innym powodem upraszczania obiektów jest zmniejszenie ilości pamięci, miejsca na dysku i przepustowości sieci, które zajmują:przed opublikowaniem złożonych
geometrii jako interaktywnych map warto je
uprościć.Pakiet**sf**udostępnia`st_simplify()`funkcję, która wykorzystuje algorytm Douglasa-Peuckera do zmniejszenia liczby wierzchołków.
`st_simplify()`wykorzystuje`dTolerance` do kontrolowania poziomu uogólnienia w jednostkach mapy . [Szczegółowe informacje@douglas_algorithms_1973można znaleźć w sekcji] .
Rysunek @ref(fig:seine-simp) ilustruje uproszczeniegeometrii`LINESTRING`  reprezentującej Sekwanę i jej dopływy.
Uproszczona geometria została utworzona za pomocą następującego polecenia:

```{r 05-geometry-operations-2}
seine_simp = st_simplify(seine, dTolerance = 2000)  # 2000 m
```

```{r seine-simp, echo=FALSE, fig.cap="Comparison of the original and simplified geometry of the seine object.", warning=FALSE, fig.scap="Simplification in action.", message=FALSE, fig.asp=0.5}
library(tmap)
p_simp1 = tm_shape(seine) + tm_lines() +
  tm_title("Original data")
p_simp2 = tm_shape(seine_simp) + tm_lines() +
  tm_title("st_simplify")
tmap_arrange(p_simp1, p_simp2, ncol = 2)
```

Wynikowy`seine_simp`obiekt jest kopią oryginalnego`seine`obiektu, ale ma mniej wierzchołków.Jest
to oczywiste, ponieważ wynik jest wizualnie prostszy (rysunek @ref(fig:seine-simp), po prawej) i zajmuje mniej pamięci niż oryginalny obiekt, co zostało zweryfikowane poniżej:

```{r 05-geometry-operations-3}
object.size(seine)
object.size(seine_simp)
```

\\index{vector!simplification}
Uproszczenie ma również zastosowanie w przypadku wielokątów.Ilustruje
to obiekt`us_states`reprezentujący sąsiadujące ze sobą stany USA.

```{r 05-geometry-operations-5}
us_states_simp1 = st_simplify(us_states, dTolerance = 100000)  # 100 km
```

Ograniczeniem funkcji`st_simplify()`jest to, że upraszcza ona obiekty na podstawie geometrii.Oznacza to
utratę „topologii”, co powoduje nakładanie się i „dziurawe” jednostki obszarowe, jak pokazano na rysunku @ref(fig:us-simp) (prawy górny panel).
`ms_simplify()`Funkcja**rmapshaper**stanowi alternatywę.
 Domyślnie używa algorytmu Visvalingama, który pokonuje niektóre ograniczenia algorytmu Douglasa-Peuckera [@visvalingam_line_1993] .

<!-- https://bost.ocks.org/mike/simplify/ -->

Poniższy fragment kodu wykorzystuje tę funkcję do uproszczenia`us_states`.
Wynik ma tylko 1% wierzchołków danych wejściowych (ustawionych za pomocą argumentu`keep`), ale liczba obiektów pozostaje niezmieniona, ponieważ ustawiliśmy`keep_shapes = TRUE`:^\[
Uproszczenie obiektów wielokątnych może spowodować usunięcie małych wielokątów wewnętrznych, nawet jeśliargument`keep_shapes`  jest ustawiony na TRUE. Aby temu zapobiec, należy ustawić`explode = TRUE`. Opcja ta konwertuje wszystkie wielokąty na oddzielne wielokąty przed ich uproszczeniem.
\]

```{r 05-geometry-operations-6, warning=FALSE, message=FALSE}
# proportion of points to retain (0-1; default 0.05)
us_states_simp2 = rmapshaper::ms_simplify(us_states, keep = 0.01,
                                          keep_shapes = TRUE)
```

\\index{vector!simplification}
Alternatywnym procesem do uproszczenia jest wygładzanie granic geometrii wielokątów i ciągów linii, które jest zaimplementowane wpakiecie**smoothr**\\index{smoothr (package)}.
Wygładzanie interpoluje krawędzie geometrii i niekoniecznie prowadzi do zmniejszenia liczby wierzchołków, ale może być szczególnie przydatne podczas pracy z geometriami powstałymi w wyniku wektoryzacji rastra (temat omówiony w rozdziale @ref(raster-vector)).
**smoothr**implementuje trzy techniki wygładzania: regresję jądra Gaussa, algorytm przycinania narożników Chaikina oraz interpolację splajnu, które są opisane w winiecie pakietu i[na stronie internetowej](https://strimas.com/smoothr/).
Należy zauważyć, że podobnie jak`st_simplify()`wprzypadku, algorytmy wygładzania nie zachowują „topologii”.
Podstawową funkcją**smoothr**jest`smooth()`, gdzieargument`method`  określa, która technika wygładzania ma być użyta.
Poniżej znajduje się przykład użycia regresji jądra Gaussa do wygładzenia granic stanów USA przy użyciu`method=ksmooth`.
Argument`smoothness`  kontroluje szerokość pasma Gaussa używanego do wygładzenia geometrii i ma domyślną wartość 1.

```{r 05-geometry-operations-6b, warning=FALSE}
us_states_simp3 = smoothr::smooth(us_states, method = "ksmooth", smoothness = 6)
```

Na koniec, wizualne porównanie oryginalnego zbioru danych z uproszczoną i wygładzoną wersją pokazano na rysunku @ref(fig:us-simp).
Można zaobserwować różnice między wynikamialgorytmówDouglasa-Peuckera (`st_simplify`), Visvalingama (`ms_simplify`) i regresji jądra Gaussa (`smooth(method=ksmooth`).

```{r us-simp, echo=FALSE, fig.cap="Polygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.", warning=FALSE, fig.scap="Polygon simplification in action."}
library(tmap)
p_ussimp1 = tm_shape(us_states) + tm_polygons() + tm_title("Original data")
p_ussimp2 = tm_shape(us_states_simp1) + tm_polygons() + tm_title("st_simplify")
p_ussimp3 = tm_shape(us_states_simp2) + tm_polygons() + tm_title("ms_simplify")
p_ussimp4 = tm_shape(us_states_simp3) + tm_polygons() + tm_title('smooth(method = "ksmooth")')
tmap_arrange(p_ussimp1, p_ussimp2, p_ussimp3, p_ussimp4, ncol = 2, nrow = 2)
```

### Centroidy

\\indexOperacje{vector!centroids}
centroidalne identyfikują środek obiektów geograficznych.
Podobnie jak w przypadku statystycznych miar tendencji centralnej (w tym definicji średniej i mediany „średniej”), istnieje wiele sposobów definiowania geograficznego środka obiektu.
Wszystkie one tworzą jednopunktowe reprezentacje bardziej złożonych obiektów wektorowych.

Najczęściej stosowaną operacją centroidową jest*centroid**geograficzny*.
Ten rodzaj operacji centroidowej (często nazywany „centroidem”) reprezentuje środek masy obiektu przestrzennego (wyobraź sobie talerz balansujący na palcu).
Centrum ciężkości geograficzne ma wiele zastosowań, na przykład do tworzenia prostych reprezentacji punktów złożonych geometrii lub do szacowania odległości między wielokątami.
Można je obliczyć za pomocąfunkcji**sf**`st_centroid()`,jak pokazano w poniższym kodzie, który generuje centra ciężkości geograficzne regionów Nowej Zelandii i dopływów Sekwany, zilustrowane czarnymi punktami na rysunku @ref(fig:centr).

```{r 05-geometry-operations-7, warning=FALSE}
nz_centroid = st_centroid(nz)
seine_centroid = st_centroid(seine)
```

Czasami centroid geograficzny znajduje się poza granicami obiektów nadrzędnych (np. pączek).
W takich przypadkachmożna użyć operacji*punktowych na powierzchni*, aby zagwarantować, że punkt będzie znajdował się w obiekcie nadrzędnym (np. w celu oznaczenia nieregularnych obiektów wielokątnych, takich jak państwa wyspiarskie), co ilustrują czerwone punkty na rysunku @ref(fig:centr).
Należy zauważyć, że te czerwone punkty zawsze leżą na obiektach nadrzędnych.
Zostały one utworzone za pomocą`st_point_on_surface()`w następujący sposób:^\[
Opis działania  znajduje`st_point_on_surface()`się na stronie https://gis.stackexchange.com/a/76563/20955.
\]

```{r 05-geometry-operations-8, warning=FALSE}
nz_pos = st_point_on_surface(nz)
seine_pos = st_point_on_surface(seine)
```

```{r centr, warning=FALSE, echo=FALSE, fig.cap="Centroids (black points) and 'points on surface' (red points) of New Zealand's regions (left) and the Seine (right) datasets.", fig.scap="Centroid vs. point on surface operations."}
p_centr1 = tm_shape(nz) + tm_polygons(col = "gray80", fill = "gray90") +
  tm_shape(nz_centroid) + tm_symbols(shape = 1, col = "black", size = 0.5) +
  tm_shape(nz_pos) + tm_symbols(shape = 1, col = "red", size = 0.5) +
  tm_layout(scale = 1.6)
p_centr2 = tm_shape(seine) + tm_lines(col = "gray80") +
  tm_shape(seine_centroid) + tm_symbols(shape = 1, col = "black", size = 0.5) +
  tm_shape(seine_pos) + tm_symbols(shape = 1, col = "red", size = 0.5) +
  tm_add_legend(type = "symbols", shape = 1, col = c("black", "red"), 
                labels = c("Centroid", "Point on surface")) +
  tm_layout(scale = 1.6)
tmap_arrange(p_centr1, p_centr2, ncol = 2)
```

Istnieją inne rodzaje centroidów, w tym*centrum**Czebyszewa*i*centrum**wizualne*.Nie
będziemy ich tutaj omawiać, ale można je obliczyć za pomocą języka R, co zobaczymy w rozdziale @ref(algorithms).

### Bufory

\\index{vector!buffers}
Bufory to wielokąty reprezentujące obszar w określonej odległości od obiektu geometrycznego:
niezależnie od tego, czy dane wejściowe są punktem, linią czy wielokątem, wynikiem jest wielokąt.
W przeciwieństwie do uproszczenia (które jest często stosowane do wizualizacji i zmniejszenia rozmiaru pliku), buforowanie jest zazwyczaj wykorzystywane do analizy danych geograficznych.
Ile punktów znajduje się w określonej odległości od tej linii?
Które grupy demograficzne znajdują się w odległości umożliwiającej dojazd do tego nowego sklepu?
Na tego typu pytania można odpowiedzieć i zwizualizować je, tworząc bufory wokół interesujących nas obiektów geograficznych.

Rysunek @ref(fig:buffs) ilustruje bufory o różnych rozmiarach (5 i 50 km) otaczające Sekwanę i jej dopływy.Bufory
te zostały utworzone za pomocą poniższych poleceń, które pokazują,że polecenie`st_buffer()`wymaga co najmniej dwóch argumentów: geometrii wejściowej i odległości podanej w jednostkach CRS (w tym przypadku w metrach).

```{r 05-geometry-operations-9}
seine_buff_5km = st_buffer(seine, dist = 5000)
seine_buff_50km = st_buffer(seine, dist = 50000)
```

```{r buffs, echo=FALSE, fig.cap="Buffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.", fig.show="hold", out.width="100%", fig.scap="Buffers around the seine dataset."}
p_buffs1 = tm_shape(seine_buff_5km) + tm_polygons(fill =   "name") +
  tm_shape(seine) + tm_lines() +
  tm_title("5 km buffer") +
  tm_layout(legend.show = FALSE)
p_buffs2 = tm_shape(seine_buff_50km) + tm_polygons(fill =   "name") +
  tm_shape(seine) + tm_lines() +
  tm_title("50 km buffer") +
  tm_layout(legend.show = FALSE)
tmap_arrange(p_buffs1, p_buffs2, ncol = 2)  
```

```{block2 05-geometry-operations-10, type="rmdnote"}
The `st_buffer()` has a few additional arguments. 
The most important ones are:

- `nQuadSegs` (when the GEOS\index{GEOS} engine is used), which means 'number of segments per quadrant' and is set by default to 30 (meaning circles created by buffers are composed of $4 \times 30 = 120$ lines).
Unusual cases where it may be useful include when the memory consumed by the output of a buffer operation is a major concern (in which case it should be reduced) or when very high precision is needed (in which case it should be increased)
- `max_cells` (when the S2\index{S2} engine is used), the larger the value, the more smooth the buffer will be, but the calculations will take longer
- `endCapStyle` and `joinStyle` (when the GEOS engine is used), which control the appearance of the buffer's edges
- `singleSide` (when the GEOS engine is used), which controls whether the buffer is created on one or both sides of the input geometry

```

```{r nQuadSegs, eval=FALSE, echo=FALSE}
# Demonstrate nQuadSegs
seine_buff_simple = st_buffer(seine, dist = 50000, nQuadSegs = 3)
plot(seine_buff_simple, key.pos = NULL, main = "50 km buffer")
plot(seine, key.pos = NULL, lwd = 3, pal = rainbow, add = TRUE)
seine_points = st_cast(seine[1, ], "POINT")
buff_single = st_buffer(seine_points[1, ], 50000, 2)
buff_points = st_cast(buff_single, "POINT")
plot(st_geometry(buff_single), add = TRUE)
```

```{r buffargs, eval=FALSE, echo=FALSE}
seine_wgs = st_transform(seine, "EPSG:4326")
plot(st_buffer(seine, 5000))
plot(st_buffer(seine_wgs, 5000))
plot(st_buffer(seine, 5000, nQuadSegs = 1))
plot(st_buffer(seine_wgs, 5000, nQuadSegs = 1)) # no effect
plot(st_buffer(seine, 5000, max_cells = 10)) # no effect
plot(st_buffer(seine_wgs, 5000, max_cells = 100))
plot(st_buffer(seine, 5000, endCapStyle = "FLAT", joinStyle = "MITRE"))
plot(st_buffer(seine_wgs, 5000, endCapStyle = "FLAT", joinStyle = "MITRE")) # no effect
plot(st_buffer(seine, 5000, singleSide = TRUE))
plot(st_buffer(seine_wgs, 5000, singleSide = TRUE)) # no effect
```

### Przekształcenia afiniczne

\\index{vector!affine transformation}
Przekształcenie afiniczne to dowolne przekształcenie, które zachowuje linie i równoległość.
Jednak kąty lub długości niekoniecznie są zachowywane.
Przekształcenia afiniczne obejmują między innymi przesunięcie (translację), skalowanie i obrót.
Dodatkowo można stosować dowolną kombinację tych transformacji.
Transformacje afiniczne są istotną częścią geokomputacji.
Na przykład przesunięcie jest potrzebne do umieszczenia etykiet, skalowanie jest stosowane w kartogramach obszarów nieprzylegających (patrz sekcja @ref(other-mapping-packages)), a wiele transformacji afinicznych jest stosowanych podczas reprojekcji lub poprawiania geometrii, która została utworzona na podstawie zniekształconej lub błędnie wykreślonej mapy.
Pakiet**sf**implementuje transformację afiniczną dla obiektów klas`sfg`i`sfc`.

```{r 05-geometry-operations-11}
nz_sfc = st_geometry(nz)
```

Przesunięcie powoduje przesunięcie każdego punktu o tę samą odległość w jednostkach mapy.
Można to zrobić, dodając wektor numeryczny do obiektu wektorowego.
Na przykład poniższy kod przesuwa wszystkie współrzędne y o 100 000 metrów na północ, ale pozostawia współrzędne x bez zmian (rysunek @ref(fig:affine-trans), lewy panel).

```{r 05-geometry-operations-12}
nz_shift = nz_sfc + c(0, 100000)
```

Skalowanie powiększa lub zmniejsza obiekty o określony współczynnik.
Można je zastosować globalnie lub lokalnie.Skalowanie
globalne zwiększa lub zmniejsza wszystkie wartości współrzędnych w stosunku do współrzędnych początkowych, zachowując jednocześnie wszystkie relacje topologiczne geometrii.
Można to zrobić poprzez odejmowanie lub mnożenieobiektu`sfg`lub`sfc`.

```{r 05-geometry-operations-13, echo=FALSE, eval=FALSE}
nz_scale0 = nz_sfc * 0.5
```

Skalowanie lokalne traktuje geometrie niezależnie i wymaga punktów, wokół których geometrie będą skalowane, np. centroidów.
W poniższym przykładzie każda geometria jest zmniejszana dwukrotnie wokół centroidów (rysunek @ref(fig:affine-trans), środkowy panel).
Aby to osiągnąć, każdy obiekt jest najpierw przesuwany w taki sposób, aby jego środek miał współrzędne`0, 0`(`(nz_sfc - nz_centroid_sfc)`).
Następnie rozmiary geometrii są zmniejszane o połowę (`* 0.5`).
Na koniec centroid każdego obiektu jest przesuwany z powrotem do współrzędnych danych wejściowych (`+ nz_centroid_sfc`).

```{r 05-geometry-operations-14}
nz_centroid_sfc = st_centroid(nz_sfc)
nz_scale = (nz_sfc - nz_centroid_sfc) * 0.5 + nz_centroid_sfc
```

Obrót współrzędnych dwuwymiarowych wymaga macierzy obrotu:

obraca

$$
R =
\begin{bmatrix}
\cos \theta & -\sin \theta \\sin \theta & \cos \theta \
\end{bmatrix}
$$

ona punkty zgodnie z ruchem wskazówek zegara.
Macierz obrotu można zaimplementować w języku R jako:

```{r 05-geometry-operations-15}
rotation = function(a){
  r = a * pi / 180 #degrees to radians
  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)
} 
```

Funkcja`rotation`  przyjmuje jeden argument`a`\--- kąt obrotu w stopniach.
Obrót można wykonać wokół wybranych punktów, takich jak centroidy (rysunek @ref(fig:affine-trans), prawy panel).Więcej
przykładówmożna`vignette("sf3")`znaleźćw  .

```{r 05-geometry-operations-16}
nz_rotate = (nz_sfc - nz_centroid_sfc) * rotation(30) + nz_centroid_sfc
```

```{r affine-trans, echo=FALSE, fig.cap="Affine transformations: shift, scale and rotate.", warning=FALSE, eval=TRUE, fig.scap="Affine transformations."}
st_crs(nz_shift) = st_crs(nz_sfc)
st_crs(nz_scale) = st_crs(nz_sfc)
st_crs(nz_rotate) = st_crs(nz_sfc)
p_at1 = tm_shape(nz_sfc) + tm_polygons() +
  tm_shape(nz_shift) + tm_polygons(fill = "red") +
  tm_title("Shift")
p_at2 = tm_shape(nz_sfc) + tm_polygons() +
  tm_shape(nz_scale) + tm_polygons(fill = "red") +
  tm_title("Scale")
p_at3 = tm_shape(nz_sfc) + tm_polygons() +
  tm_shape(nz_rotate) + tm_polygons(fill = "red") +
  tm_title("Rotate")
tmap_arrange(p_at1, p_at2, p_at3, ncol = 3)
```

```{r 05-geometry-operations-17, echo=FALSE, eval=FALSE}
nz_scale_rotate = (nz_sfc - nz_centroid_sfc) * 0.25 * rotation(90) + nz_centroid_sfc
```

```{r 05-geometry-operations-18, echo=FALSE, eval=FALSE}
shearing = function(hx, hy){
  matrix(c(1, hy, hx, 1), nrow = 2, ncol = 2)
}
nz_shear = (nz_sfc - nz_centroid_sfc) * shearing(1.1, 0) + nz_centroid_sfc
```

```{r 05-geometry-operations-19, echo=FALSE, eval=FALSE}
plot(nz_sfc)
plot(nz_shear, add = TRUE, col = "red")
```

Wreszcie, nowo utworzone geometrie mogą zastąpić stare za pomocą`st_set_geometry()`funkcji:

```{r 05-geometry-operations-20}
nz_scale_sf = st_set_geometry(nz, nz_scale)
```

### Clipping{#clipping}

\\index{vector!clipping}
\\index{spatial!subsetting}
Przycinanie przestrzenne jest formą przestrzennego podziału, która wiąże się ze zmianami w`geometry`kolumnach przynajmniej niektórych z zainteresowanych obiektów.

Przycinanie może mieć zastosowanie tylko do elementów bardziej złożonych niż punkty:
linii, wielokątów i ich „wielokrotnych” odpowiedników.
Aby zilustrować tę koncepcję, zaczniemy od prostego przykładu:
dwóch nakładających się okręgów o promieniu równym jeden, których punkty środkowe są oddalone od siebie o jedną jednostkę (rysunek @ref(fig:points)).

```{r points, fig.cap="Overlapping circles.", fig.asp=0.4, crop=TRUE, echo=-1}
op = par(mar = rep(0, 4))
b = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # create 2 points
b = st_buffer(b, dist = 1) # convert points to circles
plot(b, border = "gray")
text(x = c(-0.5, 1.5), y = 1, labels = c("x", "y"), cex = 3) # add text
```

```{r, echo=FALSE}
par(op)
```

Wyobraź sobie, że chcesz wybrać nie jedno lub drugie koło, ale obszar pokryty przez oba`x`*i*`y`.
Można to zrobić za pomocą funkcji`st_intersection()`\\index{vector!intersection}, zilustrowanej za pomocą obiektów o nazwach`x`i`y`które reprezentują lewe i prawe koło (rysunek @ref(fig:circle-intersection)).

```{r circle-intersection, fig.cap="Overlapping circles with a gray color indicating intersection between them.", fig.asp=0.4, fig.scap="Overlapping circles showing intersection types.", crop=TRUE, echo=-1}
op = par(mar = rep(0, 4))
x = b[1]
y = b[2]
x_and_y = st_intersection(x, y)
plot(b, border = "gray")
plot(x_and_y, col = "lightgray", border = "gray", add = TRUE) # intersecting area
```

```{r, echo=FALSE}
par(op)
```

Poniższy fragment kodu pokazuje, jak to działa dla wszystkich kombinacji diagramu Venna reprezentującego`x`i`y`, zainspirowanego[rysunkiem 5.1](https://r4ds.had.co.nz/transform.html#logical-operators)z książki*R for Data Science* [@grolemund_r_2016] .

```{r venn-clip, echo=FALSE, fig.cap="Spatial equivalents of logical operators.", warning=FALSE}
source("code/05-venn-clip.R")
```

### Podzbiory i przycinanie

\\index{vector!clipping}
\\index{spatial!subsetting}
Przycinanie obiektów może zmienić ich geometrię, ale może również tworzyć podzbiory obiektów, zwracając tylko elementy, które przecinają się (lub częściowo przecinają się) z obiektem przycinającym/tworzącym podzbiór.
Aby zilustrować tę kwestię, utworzymy podzbiór punktów pokrywających obwiednię okręgów`x`i`y`na rysunku @ref(fig:venn-clip).
Niektóre punkty będą znajdować się tylko w jednym okręgu, niektóre w obu, a niektóre w żadnym.Poniżej
`st_sample()`użyto funkcji do wygenerowania*prostego losowego*rozkładu punktów w obrębie okręgów`x`i`y`, co dało wynik przedstawiony na rysunku @ref(fig:venn-subset) i nasuwa pytanie: jak utworzyć podzbiór punktów, aby zwrócić tylko punkty, które przecinają się*zarówno*zjak`x`i`y`?

```{r venn-subset, fig.cap="Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.", fig.height=6, fig.width=9, fig.scap="Randomly distributed points within the bounding box. Note that only one point intersects with both x and y, highlighted with a red circle.", echo=FALSE}
op = par(mar = rep(0, 4))
bb = st_bbox(st_union(x, y))
box = st_as_sfc(bb)
set.seed(2024)
p = st_sample(x = box, size = 10)
p_xy1 = p[x_and_y]
plot(box, border = "gray", lty = 2)
plot(x, add = TRUE, border = "gray")
plot(y, add = TRUE, border = "gray")
plot(p, add = TRUE, cex = 3.5)
plot(p_xy1, cex = 5, col = "red", add = TRUE)
text(x = c(-0.5, 1.5), y = 1, labels = c("x", "y"), cex = 3)
```

```{r, echo=FALSE}
par(op)
```

```{r venn-subset-to-show, eval=FALSE}
bb = st_bbox(st_union(x, y))
box = st_as_sfc(bb)
set.seed(2024)
p = st_sample(x = box, size = 10)
x_and_y = st_intersection(x, y)
```

Poniższy fragment kodu pokazuje trzy sposoby osiągnięcia tego samego rezultatu.
Możemy użyć przecięcia\\indeksu{vector!intersection}  i`y``x`(przedstawionego jako`x_and_y`w poprzednim fragmencie kodu) jako obiektu podzbioru bezpośrednio, jak pokazano w pierwszym wierszu poniższego fragmentu kodu.
Możemy również znaleźć*przecięcie*między punktami wejściowymi reprezentowanymi przez`p`a obiektem`x_and_y`podzbioru/wycinania, jak pokazano w drugim wierszu poniższego fragmentu kodu.
To drugie podejście zwróci elementy, które częściowo przecinają się z`x_and_y`ale z modyfikowanymi geometriami dla elementów o dużym zasięgu przestrzennym, które przekraczają granicę obiektu podzbioru.
Trzecie podejście polega na utworzeniu obiektu podzbioru przy użyciu binarnego predykatu`st_intersects()`przestrzennego, wprowadzonego w poprzednim rozdziale.
Wyniki są identyczne (z wyjątkiem powierzchownych różnic w nazwach atrybutów), ale implementacja różni się znacznie:

```{r 05-geometry-operations-21}
# way #1
p_xy1 = p[x_and_y]
# way #2
p_xy2 = st_intersection(p, x_and_y)
# way #3
sel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] & 
  st_intersects(p, y, sparse = FALSE)[, 1]
p_xy3 = p[sel_p_xy]
```

```{r 05-geometry-operations-22, echo=FALSE, eval=FALSE}
# test if objects are identical:
identical(p_xy1, p_xy2)
identical(p_xy2, p_xy3)
identical(p_xy1, p_xy3)
waldo::compare(p_xy1, p_xy2) # the same except attribute names
waldo::compare(p_xy2, p_xy3) # the same except attribute names

# An alternative way to sample from the bb
bb = st_bbox(st_union(x, y))
pmulti = st_multipoint(pmat)
box = st_convex_hull(pmulti)
```

Chociaż powyższy przykład jest raczej sztuczny i ma charakter edukacyjny, a nie praktyczny, i zachęcamy czytelnika do odtworzenia wyników w celu pogłębienia zrozumienia obsługi obiektów wektorowych w R, rodzi on ważne pytanie: które wdrożenie wybrać?
Ogólnie rzecz biorąc, należy preferować bardziej zwięzłe wdrożenia, czyli pierwsze z powyższych podejść.Do kwestii wyboru między różnymi
wdrożeniami tej samej techniki lub algorytmu powrócimy w rozdziale @ref(algorithms).

### Związki geometryczne

\\index{vector!union}
\\index{aggregation!spatial}
Jak widzieliśmy w sekcji @ref(vector-attribute-aggregation), agregacja przestrzenna może po cichu rozpuścić geometrie stykających się wielokątów w tej samej grupie.Pokazuje
to poniższy fragment kodu, w którym 48 stanów USA i Dystrykt Kolumbii (`us_states`) są agregowane do czterech regionów przy użyciufunkcjibase{dplyr (package)}i**dplyr**\\index(wyniki przedstawiono na rysunku @ref(fig:us-regions)):

```{r 05-geometry-operations-23}
regions = aggregate(x = us_states[, "total_pop_15"], by = list(us_states$REGION),
                    FUN = sum, na.rm = TRUE)
regions2 = us_states |> 
  group_by(REGION) |>
  summarize(pop = sum(total_pop_15, na.rm = TRUE))
```

```{r 05-geometry-operations-24, echo=FALSE}
# st_join(buff, africa[, "pop"]) |>
#   summarize(pop = sum(pop, na.rm = TRUE))
# summarize(africa[buff, "pop"], pop = sum(pop, na.rm = TRUE))
```

```{r us-regions, fig.cap="Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.", echo=FALSE, warning=FALSE, out.width="100%", fig.scap="Spatial aggregation on contiguous polygons."}
source("code/05-us-regions.R", print.eval = TRUE)
```

Co dzieje się z geometriami?
W tle zarówno`aggregate()`jak i`summarize()`łączą geometrie i rozpuszczają granice między nimi za pomocą`st_union()`.Pokazuje
to poniższy fragment kodu, który tworzy zjednoczone zachodnie Stany Zjednoczone:

```{r 05-geometry-operations-25}
us_west = us_states[us_states$REGION == "West", ]
us_west_union = st_union(us_west)
```

Funkcja może pobierać dwie geometrie i łączyć je, jak pokazano w poniższym fragmencie kodu, który tworzy połączony blok zachodni obejmujący Teksas (wyzwanie: odtworzyć i wykreślić wynik):

```{r 05-geometry-operations-26, message=FALSE}
texas = us_states[us_states$NAME == "Texas", ]
texas_union = st_union(us_west_union, texas)
```

```{r 05-geometry-operations-27, echo=FALSE, eval=FALSE}
plot(texas_union)
# aim: experiment with st_union
us_south2 = st_union(us_west[1, ], us_west[6, ])
plot(us_southhwest)
```

### Transformacje typu{#type-trans}

\\index{vector!geometry casting}
Przekształcanie geometrii to potężna operacja, która umożliwia transformację typu geometrii.Jest ona zaimplementowana w
funkcji`st_cast()`  zpakietu**sf**.
Co ważne,`st_cast()`zachowuje się inaczej w przypadku pojedynczychobiektówgeometrii prostych (`sfg`) obiektów, kolumn geometrii prostych (`sfc`) i obiektów prostych.

Stwórzmy wielopunkt, aby zilustrować,jak przekształcanie geometrii działa naobiektachgeometrii prostych obiektów (`sfg`)

W

```{r 05-geometry-operations-28}
multipoint = st_multipoint(matrix(c(1, 3, 5, 1, 3, 1), ncol = 2))
```

tym przypadkumoże być przydatne do przekształcenia nowego obiektu w ciąg`st_cast()`linii lub wielokąt (rysunek @ref(fig:single-cast)).

```{r 05-geometry-operations-29}
linestring = st_cast(multipoint, "LINESTRING")
polyg = st_cast(multipoint, "POLYGON")
```

```{r single-cast, echo=FALSE, fig.cap="Examples of a linestring and a polygon casted from a multipoint geometry.", warning=FALSE, fig.asp=0.3, fig.scap="Examples of casting operations."}
p_sc1 = tm_shape(st_sfc(multipoint, crs = "+proj=merc")) + tm_symbols(shape = 1,
                                                  col = "black",
                                                  size = 0.5) +
  tm_title("MULTIPOINT") +
  tm_layout(inner.margins = c(0.15, 0.05, 0.15, 0.05))
p_sc2 = tm_shape(st_sfc(linestring, crs = "+proj=merc")) + tm_lines() +
  tm_title("LINESTRING") +
  tm_layout(inner.margins = c(0.15, 0.05, 0.15, 0.05))
p_sc3 = tm_shape(st_sfc(polyg, crs = "+proj=merc")) + tm_polygons(col = "black") +
  tm_title("POLYGON") +
  tm_layout(inner.margins = c(0.15, 0.05, 0.15, 0.05))
tmap_arrange(p_sc1, p_sc2, p_sc3, ncol = 3)
```

Konwersja z wielopunktu do ciągu linii jest powszechną operacją, która tworzy obiekt liniowy na podstawie uporządkowanych obserwacji punktów, takich jak pomiary GPS lub media z geotagami.
To z kolei pozwala nam wykonywać operacje przestrzenne, takie jak obliczanie długości przebytej trasy.
Konwersja z wielopunktu lub ciągu linii do wielokąta jest często wykorzystywana do obliczania powierzchni, na przykład na podstawie zestawu pomiarów GPS wykonanych wokół jeziora lub narożników działki budowlanej.

Proces transformacji można również odwrócić za pomocą`st_cast()`:

```{r 05-geometry-operations-30}
multipoint_2 = st_cast(linestring, "MULTIPOINT")
multipoint_3 = st_cast(polyg, "MULTIPOINT")
all.equal(multipoint, multipoint_2)
all.equal(multipoint, multipoint_3)
```

```{block2 05-geometry-operations-31, type="rmdnote"}
For single simple feature geometries (`sfg`), `st_cast()` also provides geometry casting from non-multi-types to multi-types (e.g., `POINT` to `MULTIPOINT`) and from multi-types to non-multi-types.
However, when casting from multi-types to non-multi-types, only the first element of the old object would remain in the output object.
```

```{r 05-geometry-operations-32, include=FALSE}
cast_all = function(xg) {
  lapply(c("MULTIPOLYGON", "MULTILINESTRING", "MULTIPOINT", "POLYGON", "LINESTRING", "POINT"), 
         function(x) st_cast(xg, x))
}
t = cast_all(multipoint)
t2 = cast_all(polyg)
```

Przekształcanie geometrii prostych obiektów kolumna geometrii (`sfc`) i obiekty proste działają tak samo jak w`sfg`przypadkuw większości przypadków.
Jedną z istotnych różnic jest konwersja między typami wielokrotnymi a typami nie wielokrotnymi.
W wyniku tego procesu obiekty wielokrotne`sfc`lub`sf`są dzielone na wiele obiektów nie wielokrotnych.

Załóżmy, że mamy następujące`sf`obiekty:

- `POI`\- typ POINT (z jednym punktem z definicji)
- `MPOI`\- typ MULTIPOINT z czterema punktami
- `LIN`\- typ LINESTRING z jednym ciągiem linii zawierającym pięć punktów
- `MLIN`\- typ MULTILINESTRING z dwoma ciągami linii (jednym z pięcioma punktami i jednym z dwoma punktami)
- `POL`\- typ POLYGON z jednym wielokątem (utworzony przy użyciu pięciu punktów)
- `MPOL`\- typ MULTIPOLYGON składający się z dwóch wielokątów (oba składające się z pięciu punktów)
- `GC`\- typ GEOMETRYCOLLECTION z dwiema geometriami, MULTIPOINT (cztery punkty) i LINESTRING (pięć punktów)

Tabela @ref(tab:sfs-st-cast) pokazuje możliwe transformacje typów geometrii na prostych obiektach wymienionych powyżej.
Pojedyncze geometrie prostych obiektów (przedstawione w pierwszej kolumnie tabeli) mogą być przekształcane w wiele typów geometrii, przedstawionych w kolumnach tabeli @ref(tab:sfs-st-cast).
Niektóre przekształcenia nie są możliwe: nie można na przykład przekształcić pojedynczego punktu w ciąg wielokrotny lub wielokąt, co wyjaśnia, dlaczego komórki`[1, 4:5]`w tabeli zawierają wartość NA.
Niektóre transformacje dzielą pojedyncze obiekty wejściowe na wiele podobiektów, „rozszerzając”`sf`obiekty (dodając nowe wiersze z zduplikowanymi wartościami atrybutów).Na przykład
, gdy geometria wielopunktowa składająca się z pięciu par współrzędnych zostanie przekształcona w geometrię „POINT”, wynik będzie zawierał pięć obiektów.

```{r sfs-st-cast, echo=FALSE}
sfs_st_cast = read.csv("extdata/sfs-st-cast.csv")
abbreviate_geomtypes = function(geomtypes) {
  geomtypes_new = gsub(pattern = "POINT", replacement = "POI", x = geomtypes)
  geomtypes_new = gsub(pattern = "POLYGON", replacement = "POL", x = geomtypes_new)
  geomtypes_new = gsub(pattern = "LINESTRING", replacement = "LIN", x = geomtypes_new)
  geomtypes_new = gsub(pattern = "MULTI", replacement = "M", x = geomtypes_new)
  geomtypes_new = gsub(pattern = "GEOMETRYCOLLECTION", replacement = "GC", x = geomtypes_new)
  geomtypes_new
}
sfs_st_cast$input_geom = abbreviate_geomtypes(sfs_st_cast$input_geom)
names(sfs_st_cast) = abbreviate_geomtypes(names(sfs_st_cast))
names(sfs_st_cast)[1] = ""
knitr::kable(sfs_st_cast, 
             caption = paste("Geometry casting on simple feature geometries", 
                             "(see Section 2.1) with input type by row and", 
                             "output type by column."),
             caption.short = "Geometry casting on simple feature geometries.",
             booktabs = TRUE) |> 
  kableExtra::add_footnote("Values in parentheses represent the number of features; NA means the operation is not available", notation = "none")
```

Spróbujmy zastosować transformacje typu geometrycznego do nowego obiektu,`multilinestring_sf`jako przykład (po lewej stronie na rysunku @ref(fig:line-cast)):

```{r 05-geometry-operations-33}
multilinestring_list = list(matrix(c(1, 4, 5, 3), ncol = 2), 
                            matrix(c(4, 4, 4, 1), ncol = 2),
                            matrix(c(2, 4, 2, 2), ncol = 2))
multilinestring = st_multilinestring(multilinestring_list)
multilinestring_sf = st_sf(geom = st_sfc(multilinestring))
multilinestring_sf
```

Można to sobie wyobrazić jako sieć dróg lub rzek.
Nowy obiekt ma tylko jeden wiersz

,

który definiuje wszystkie linie.
Ogranicza to liczbę operacji, które można wykonać, na przykład uniemożliwia dodawanie nazw do każdego odcinka linii lub obliczanie długości pojedynczych linii.
W tej sytuacji można użyć funkcji`st_cast()`, ponieważ dzieli ona jeden ciąg wieloliniowy na trzy ciągi liniowe.

Nowo

```{r 05-geometry-operations-34}
linestring_sf2 = st_cast(multilinestring_sf, "LINESTRING")
linestring_sf2
```

```{r line-cast, echo=FALSE, fig.cap="Examples of type casting between multilinestring (left) and linestring (right).", warning=FALSE, fig.scap="Examples of type casting.", message=FALSE}
p_lc1 = tm_shape(multilinestring_sf) + tm_lines(lwd = 3) +
  tm_title("MULTILINESTRING")
linestring_sf2$name = c("Riddle Rd", "Marshall Ave", "Foulke St")
p_lc2 = tm_shape(linestring_sf2) + tm_lines(lwd = 3, col = "name", col.scale = tm_scale(values = "Set2")) +
  tm_title("LINESTRING") +
  tm_layout(legend.show = FALSE)
tmap_arrange(p_lc1, p_lc2, ncol = 2)
```

utworzony obiekt umożliwia tworzenie atrybutów (więcej informacji w sekcji @ref(vec-attr-creation)) i pomiary długości:

## Operacje

```{r 05-geometry-operations-35}
linestring_sf2$name = c("Riddle Rd", "Marshall Ave", "Foulke St")
linestring_sf2$length = st_length(linestring_sf2)
linestring_sf2
```

## geometryczne na danych{#geo-ras}rastrowych

\\index{raster!manipulation}
Geometryczne operacje rastrowe obejmują przesuwanie, odwracanie, lustrzane odbicie, skalowanie, obracanie lub zniekształcanie obrazów.
 Operacje te są niezbędne w wielu zastosowaniach, w tym w georeferencjonowaniu, które służy do nakładania obrazów na dokładną mapę o znanym układzie współrzędnych CRS [@liu_essential_2009] .Istnieje wiele technik
georeferencjonowania, w tym:

- Georeferencjonowanie oparte na znanych[punktach kontrolnych na ziemi](https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html)
- Ortorektyfikacja, która uwzględnia również lokalną topografię
- [Rejestracja](https://en.wikipedia.org/wiki/Image_registration)obrazówsłuży do łączenia obrazów tego samego obiektu, ale wykonanych przez różne czujniki, poprzez dopasowanie jednego obrazu do drugiego (pod względem układu współrzędnych i rozdzielczości)

R raczej nie nadaje się do pierwszych dwóch punktów, ponieważ często wymagają one ręcznej interwencji, dlatego zazwyczaj wykonuje się je za pomocą dedykowanego oprogramowania GIS (patrz również rozdział @ref(gis)).
Z drugiej strony, wyrównanie kilku obrazów jest możliwe w R, a niniejszy rozdział pokazuje między innymi, jak to zrobić.Często
wiąże się to ze zmianą zakresu, rozdzielczości i punktu początkowego obrazu.Oczywiście wymagana jest
również dopasowana projekcja, ale została ona już omówiona w rozdziale @ref(reproj-ras).

W każdym razie istnieją inne powody, aby wykonać operację geometryczną na pojedynczym obrazie rastrowym.
Na przykład w rozdziale @ref(location) definiujemy obszary metropolitalne w Niemczech jako obszary o powierzchni 20 km^2^ pikseli i liczbie mieszkańców powyżej 500 000.
Oryginalna rasterizacja liczby mieszkańców ma jednak rozdzielczość 1 km^2^, dlatego zmniejszymy (zagregujemy) rozdzielczość o współczynnik 20 (patrz sekcja @ref(define-metropolitan-areas)).
Innym powodem agregacji rastra jest po prostu skrócenie czasu działania lub oszczędność miejsca na dysku.
Oczywiście takie podejście jest zalecane tylko wtedy, gdy dane zadanie pozwala na mniejszą rozdzielczość danych rastrowych.

### Geometryczne przecięcia

\\index{raster!intersection}
W sekcji @ref(spatial-raster-subsetting) pokazaliśmy

,

jak wyodrębnić wartości z rastra pokrytego innymi obiektami przestrzennymi.
Aby uzyskać wynik przestrzenny, możemy użyć prawie tej samej składni podzbioru.
Jedyna różnica polega na tym, że musimy wyraźnie zaznaczyć

,

że chcemy zachować strukturę macierzy, ustawiającargument`drop`na`FALSE`.
Spowoduje to zwrócenie obiektu rastrowego zawierającego komórki

,

których środki pokrywają się z`clip`.

```{r 05-geometry-operations-36}
elev = rast(system.file("raster/elev.tif", package = "spData"))
clip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,
            resolution = 0.3, vals = rep(1, 9))
elev[clip, drop = FALSE]
```

Do tej samej operacji możemy również użyćpolecenia`intersect()``crop()`i.

### Zasięg i punkt początkowy

\\index{raster!merging}
Podczas łączenia lub wykonywania operacji algebry mapowej na rastrowe, ich rozdzielczość, projekcja, punkt początkowy i/lub zasięg muszą być zgodne. W przeciwnym razie, jak powinniśmy dodać wartości jednego rastra o rozdzielczości 0,2 stopnia dziesiętnego do drugiego rastra o rozdzielczości 1 stopnia dziesiętnego?
Ten sam problem pojawia się, gdy chcemy połączyć zdjęcia satelitarne z różnych czujników o różnych projekcjach i rozdzielczościach.
Możemy poradzić sobie z takimi niezgodnościami, wyrównując rastrowe obrazy.

W najprostszym przypadku dwa obrazy różnią się tylko zasięgiem.
Poniższy kod dodaje jeden wiersz i dwie kolumny po każdej stronie rastrowej mapy, ustawiając wszystkie nowe wartości na`NA`(rysunek @ref(fig:extend-example)).

```{r extend-example0}
elev = rast(system.file("raster/elev.tif", package = "spData"))
elev_2 = extend(elev, c(1, 2))
```

```{r extend-example, fig.cap="Original raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.", fig.scap="Extending rasters.", echo=FALSE, fig.asp=0.5}
source("code/05-extend-example.R", print.eval = TRUE)
```

Wykonując operację algebraiczną na dwóch obiektach o różnym zasięgu w R,pakiet**terra**zwraca błąd.

Możemy

```{r 05-geometry-operations-37, error=TRUE}
elev_3 = elev + elev_2
```

jednak wyrównać zasięg dwóch rastrów za pomocą`extend()`.
Zamiast informować funkcję, ile wierszy lub kolumn należy dodać (jak to robiono wcześniej), pozwalamy jej to obliczyć za pomocą innego obiektu rastrowego.
W tym przypadku rozszerzamyobiekt`elev`  do zakresu`elev_2`.
Wartości nowo dodanych wierszy i kolumn są ustawione na`NA`.

```{r 05-geometry-operations-38}
elev_4 = extend(elev, elev_2)
```

\\index{raster!origin}
Początek rastra to narożnik komórki najbliższy współrzędnym (0, 0).
Funkcja`origin()`  zwraca współrzędne początku.
W poniższym przykładzie narożnik komórki ma współrzędne (0, 0), ale nie zawsze tak jest.

```{r 05-geometry-operations-39}
origin(elev_4)
```

Jeśli dwa rastrowe obiekty mają różne punkty początkowe, ich komórki nie pokrywają się całkowicie, co uniemożliwia stosowanie algebry map.
Aby zmienić punkt początkowy, należy użyć`origin()`.^\[
Jeśli punkty początkowe dwóch rastrowe zbiorów danych są tylko nieznacznie oddalone od siebie, czasami wystarczy po prostu zwiększyćargument`tolerance`  funkcji`terra::terraOptions()`.
\]
Rysunek @ref(fig:origin-example) pokazuje efekt zmiany punktu początkowego w ten sposób.

```{r}
# change the origin
origin(elev_4) = c(0.25, 0.25)
```

```{r origin-example, fig.cap="Rasters with identical values but different origins.", echo=FALSE}
elev_poly = st_as_sf(as.polygons(elev, dissolve = FALSE))
elev4_poly = st_as_sf(as.polygons(elev_4, dissolve = FALSE))

tm_shape(elev4_poly) +
  tm_grid() +
  tm_polygons(fill = "elev", lwd = 0.5) +
  tm_shape(elev_poly) +
  tm_polygons(fill = "elev") +
  tm_layout(frame = FALSE, legend.show = FALSE,
            inner.margins = c(0.1, 0.12, 0, 0))
```

Należy pamiętać, że częsta zmiana rozdzielczości (następna sekcja) powoduje również zmianę punktu początkowego.

### Agregacja i dezagregacja

\\indeks{raster!aggregation}
\\indeksZbiory{raster!disaggregation}
danych rastrowych mogą się również różnić pod względem rozdzielczości.
Aby dopasować rozdzielczości, można zmniejszyć (`aggregate()`) lub zwiększyć (`disagg()`) rozdzielczość jednego rastra.^\[Mamy
tu na myśli rozdzielczość przestrzenną.
W teledetekcji ważne są również rozdzielczość spektralna (pasma spektralne), czasowa (obserwacje tego samego obszaru w czasie) i radiometryczna (głębia kolorów).Aby dowiedzieć się, jak wykonać
agregację rastrów czasowych,
zapoznaj się z`tapp()`przykładem w dokumentacji.

Jako przykład zmieniamy tutaj rozdzielczość przestrzenną(`dem`znajdującą się wpakiecie**spDataLarge**) o współczynnik 5 (rysunek @ref(fig:aggregate-example)).
Dodatkowo wartość komórki wyjściowej będzie odpowiadać średniej wartości komórek wejściowych (należy pamiętać, że można również użyć innych funkcji, takich jak`median()`,`sum()`, itp.):

```{r 05-geometry-operations-40}
dem = rast(system.file("raster/dem.tif", package = "spDataLarge"))
dem_agg = aggregate(dem, fact = 5, fun = mean)
```

```{r aggregate-example, fig.cap="Original raster (left) and aggregated raster (right).", echo=FALSE}
p_ar1 = tm_shape(dem) +
  tm_raster(col.scale = tm_scale_continuous()) +
  tm_title("A. Original") + 
  tm_layout(frame = FALSE, legend.show = FALSE)
p_ar2 = tm_shape(dem_agg) +
  tm_raster(col.scale = tm_scale_continuous()) +
  tm_title("B. Aggregated") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tmap_arrange(p_ar1, p_ar2, ncol = 2)
```

Tabela @ref(tab:aggdf) porównuje właściwości oryginalnego i zagregowanego rastra.
Należy zauważyć, że „zmniejszenie” rozdzielczości za pomocą`aggregate()`zwiększa rozdzielczość z$(30.85, 30.85)$do$(154.25, 154.25)$.Odbywa
się to poprzez zmniejszenie liczby wierszy (`nrow`) i kolumn (`ncol`) (patrz sekcja @ref(raster-data)).
Zakres został nieznacznie dostosowany, aby uwzględnić nowy

```{r aggdf}
#| echo: false
agg_df = data.frame(
  Object = c("dem", "dem_agg"),
  Resolution = c("(30.85, 30.85)", "(154.25, 154.25)"),
  Dimensions = c("117 * 117", "24 * 24"),
  Extent = c("794599.1, 798208.6, 8931775, 8935384", "794599.1, 798301.1, 8931682, 8935384")
)
knitr::kable(agg_df, caption = "Properties of the original and aggregated raster.", booktabs = TRUE)
```

rozmiar siatki.

Funkcja`disagg()`  zwiększa rozdzielczość{raster!disaggregation}
obiektów rastrowych.
Oferuje ona dwie metody obliczania wartości nowo utworzonych komórek: metoda domyślna (`method = "near"`) po prostu nadaje wszystkim komórkom wyjściowym wartość komórki wejściowej, a zatem duplikuje wartości, co przekłada się na „blokowy” wynik.
Metoda`bilinear`  wykorzystuje cztery najbliższe centra pikseli obrazu wejściowego (pomarańczowe punkty na rysunku @ref(fig:bilinear)) do obliczenia średniej ważonej odległością (strzałki na rysunku @ref(fig:bilinear)).
Wartość komórki wyjściowej jest przedstawiona jako kwadrat w lewym górnym rogu rysunku @ref(fig:bilinear).

```{r 05-geometry-operations-41}
dem_disagg = disagg(dem_agg, fact = 5, method = "bilinear")
identical(dem, dem_disagg)
```

```{r bilinear, echo=FALSE, fig.width=8, fig.height=10, fig.cap="The distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.", fig.scap="Bilinear disaggregation in action.", warning=FALSE}
source("code/05-bilinear.R", print.eval = TRUE)
# knitr::include_graphics("https://user-images.githubusercontent.com/1825120/146619205-3c0c2e3f-9e8b-4fda-b014-9c342a4befbb.png")
```

```{r}
#| echo: false
#| eval: false
identical(dem, dem_disagg)
compareGeom(dem, dem_disagg)
all.equal(dem, dem_disagg)
```

Porównanie wartości  i`dem_disagg``dem`pokazuje, że nie są one identyczne (można również użyć`compareGeom()`lub`all.equal()`).Nie było
to jednak zaskoczeniem, ponieważ dezagregacja jest prostą techniką interpolacji.
Należy pamiętać, że dezagregacja skutkuje uzyskaniem większej rozdzielczości, jednak odpowiadające jej wartości są tak samo dokładne, jak ich źródło o niższej rozdzielczości.

### Próbkowanie

\\indeks{raster!resampling}
Powyższe metody agregacji i dezagregacji są odpowiednie tylko wtedy, gdy chcemy zmienić rozdzielczość naszej siatki o współczynnik agregacji/dezagregacji.Co
jednak zrobić, gdy mamy dwie lub więcej siatek o różnych rozdzielczościach i pochodzeniu?
W tym przypadku pomocne jest ponowne próbkowanie — proces obliczania wartości dla nowych lokalizacji pikseli.
Krótko mówiąc, proces ten polega na pobraniu wartości z oryginalnej rastrowej mapy i ponownym obliczeniu nowych wartości dla docelowej rastrowej mapy o niestandardowej rozdzielczości i pochodzeniu (rysunek @ref(fig:resampl0)).

```{r resampl0, echo=FALSE, fig.cap="Resampling of an original (input) raster into a target raster with custom resolution and origin.", fig.asp=0.4}
target_rast = rast(xmin = 794650, xmax = 798250, 
                   ymin = 8931750, ymax = 8935350,
                   resolution = 150, crs = "EPSG:32717")
target_rast_p = st_as_sf(as.polygons(target_rast))
dem_resampl1 = resample(dem, target_rast, method = "near")

tm1 = tm_shape(dem) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("Original raster") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm2 = tm_shape(dem) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("Target raster") +
  tm_layout(frame = FALSE, legend.show = FALSE) +
  tm_shape(target_rast_p, is.main = TRUE) +
  tm_borders()
tm3 = tm_shape(dem) +
  tm_raster(col_alpha = 0) +
  tm_shape(dem_resampl1) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("Resampled raster") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tmap_arrange(tm1, tm2, tm3, nrow = 1)
```

\\index{raster!resampling}
Istnieje kilka metod szacowania wartości dla rastrowej mapy o różnych rozdzielczościach/pochodzeniu, jak pokazano na rysunku @ref(fig:resampl).
Główne metody ponownego próbkowania obejmują:

- Najbliższy sąsiad: przypisuje wartość najbliższej komórki oryginalnego rastra do komórki docelowego rastra. Jest to szybka i prosta technika, która zazwyczaj nadaje się do ponownego próbkowania rastrów kategorycznych.
- Interpolacja dwuliniowa: przypisuje średnią ważoną czterech najbliższych komórek z oryginalnego rastra do komórki docelowego rastra (rysunek @ref(fig:bilinear)). Jest to najszybsza metoda, odpowiednia dla rastrów ciągłych.
- Interpolacja sześcienna: wykorzystuje wartości 16 najbliższych komórek oryginalnego rastra do określenia wartości komórki wyjściowej, stosując funkcje wielomianowe trzeciego stopnia. Stosowana jest w przypadku rastrów ciągłych i daje bardziej wygładzoną powierzchnię w porównaniu z interpolacją dwuliniową, ale jest bardziej wymagająca obliczeniowo.
- Interpolacja splajnowa sześcienna: również wykorzystuje wartości 16 najbliższych komórek oryginalnej rastra do określenia wartości komórki wyjściowej, ale stosuje splajny sześcienne (funkcje wielomianowe trzeciego rzędu). Stosowana w przypadku rastrów ciągłych.
- Próbkowanie sinc z oknem Lanczosa: wykorzystuje wartości 36 najbliższych komórek oryginalnej rastra do określenia wartości komórki wyjściowej. Stosowana w przypadku rastrów ciągłych.^\[
  Bardziej szczegółowe wyjaśnienie tej metody można znaleźć na stronie https://gis.stackexchange.com/a/14361/20955.
  \]

Powyższe wyjaśnienie podkreśla, że tylkoponowne próbkowanie*najbliższego sąsiada*jest odpowiednie dla rastrów kategorycznych, podczas gdy wszystkie metody mogą być stosowane (z różnymi wynikami) dla rastrów ciągłych.
Należy również pamiętać, że metody te są coraz bardziej złożone i wymagają coraz więcej czasu przetwarzania.
Ponadto ponowne próbkowanie można przeprowadzić przy użyciu statystyk (np. minimum lub mody) wszystkich komórek, które mają wpływ na wynik.

Aby zastosować ponowne próbkowanie,pakiet**terra**udostępniafunkcję`resample()`.
Przyjmuje ona rastr wejściowy (`x`), rastr o docelowych właściwościach przestrzennych (`y`) oraz metodę ponownego próbkowania (`method`).

Aby zobaczyć,jakdziała funkcja`resample()`,potrzebujemy rastra o docelowych właściwościach przestrzennych.
W tym przykładzie tworzymy`target_rast`, ale często używa się już istniejącego obiektu rastrowego.

```{r 05-geometry-operations-42}
target_rast = rast(xmin = 794650, xmax = 798250, 
                   ymin = 8931750, ymax = 8935350,
                   resolution = 300, crs = "EPSG:32717")
```

Następnie musimy podać nasze dwa obiekty rastrowe jako pierwsze dwa argumenty i jedną z metod ponownego próbkowania opisanych powyżej.

```{r 05-geometry-operations-42b}
dem_resampl = resample(dem, y = target_rast, method = "bilinear")
```

Rysunek @ref(fig:resampl) przedstawia porównanie różnych metod ponownego próbkowaniaobiektu`dem`.

```{r resampl, echo=FALSE, fig.cap="Visual comparison of the original raster and five different resampling methods."}
dem_resampl1 = resample(dem, target_rast, method = "near")
dem_resampl2 = resample(dem, target_rast, method = "bilinear")
dem_resampl3 = resample(dem, target_rast, method = "cubic")
dem_resampl4 = resample(dem, target_rast, method = "cubicspline")
dem_resampl5 = resample(dem, target_rast, method = "lanczos")

library(tmap)
tm1 = tm_shape(dem) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("Original raster") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm2 = tm_shape(dem_resampl1) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("near") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm3 = tm_shape(dem_resampl2) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("bilinear") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm4 = tm_shape(dem_resampl3) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("cubic") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm5 = tm_shape(dem_resampl4) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("cubicspline") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tm6 = tm_shape(dem_resampl5) +
  tm_raster(col.scale = tm_scale(breaks = seq(200, 1100, by = 150))) +
  tm_title("lanczos") +
  tm_layout(frame = FALSE, legend.show = FALSE)
tmap_arrange(tm1, tm2, tm3, tm4, tm5, tm6)
```

Funkcja`resample()`posiada również dodatkowe metody ponownego próbkowania, w`sum`tym`min`,`q1`,`med`,`q3`,`max`,`average`,`mode`,i`rms`.
Wszystkie one obliczają daną statystykę na podstawie wartości wszystkich komórek siatki niebędących wartościami NA.
Na przykładjest`sum`przydatna,gdy każda komórka rastra reprezentuje zmienną o dużym zasięgu przestrzennym (np. liczbę osób).
W wyniku zastosowaniapróbkowany raster powinien mieć taką samą całkowitą liczbę osób`sum`jak raster oryginalny.

\\index{raster!resampling}
Jak widać w sekcji @ref(reproj-ras), reprojekcja rastra jest szczególnym przypadkiem próbkowania

,

gdy nasz raster docelowy ma inny układ współrzędnych (CRS) niż raster oryginalny.

\\index{GDAL}

```{block2, type="rmdnote"}
Most geometry operations in **terra** are user-friendly, rather fast, and work on large raster objects.
However, there could be some cases when **terra** is not the most performant either for extensive rasters or many raster files, and some alternatives should be considered.

The most established alternatives come with the GDAL library.
It contains several utility functions, including:

- `gdalinfo` - lists various information about a raster file, including its resolution, CRS, bounding box, and more
- `gdal_translate` - converts raster data between different file formats
- `gdal_rasterize` - converts vector data into raster files
- `gdalwarp` - allows for raster mosaicing, resampling, cropping, and reprojecting

All of the above functions are written in C++, but can be called in R using `sf::gdal_utils()`, the **gdalUtilities** package, or via system commands (see Section \@ref(gdal)).
Importantly, all of these functions expect a raster file path as an input and often return their output as a raster file (for example, `gdalUtilities::gdal_translate("my_file.tif", "new_file.tif", t_srs = "EPSG:4326")`).
This is very different from the usual **terra** approach, which expects `SpatRaster` objects as inputs.
```

## Ćwiczenia

```{r, echo=FALSE, results="asis"}
res = knitr::knit_child('_05-ex.Rmd', quiet = TRUE, options = list(include = FALSE, eval = FALSE))
cat(res, sep = '\n')
```


