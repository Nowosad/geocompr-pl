```{r 05-ex-e0, message=FALSE}
library(sf)
library(terra)
library(dplyr)
library(spData)
library(spDataLarge)
```

E1. Wygeneruj i wykreśl uproszczone wersjezbiorudanych`nz`.
Eksperymentuj z różnymi wartościami`keep`(w zakresie od 0,5 do 0,00005) dla`ms_simplify()`oraz`dTolerance`(od 100 do 100 000)`st_simplify()`.

- Przy jakiej wartości forma wyniku zaczyna się psuć dla każdej z metod, sprawiając, że Nowa Zelandia staje się nierozpoznawalna?
- Zaawansowane: Czym różni się typ geometrii wyników z`st_simplify()`od typu geometrii`ms_simplify()`? Jakie problemy to stwarza i jak można je rozwiązać?

```{r 05-ex-e1}
plot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.5))
plot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.05))
# Starts to breakdown here at 0.5% of the points:
plot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.005))
# At this point no further simplification changes the result
plot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.0005))
plot(rmapshaper::ms_simplify(st_geometry(nz), keep = 0.00005))
plot(st_simplify(st_geometry(nz), dTolerance = 100))
plot(st_simplify(st_geometry(nz), dTolerance = 1000))
# Starts to breakdown at 10 km:
plot(st_simplify(st_geometry(nz), dTolerance = 10000))
plot(st_simplify(st_geometry(nz), dTolerance = 100000))
plot(st_simplify(st_geometry(nz), dTolerance = 100000, preserveTopology = TRUE))

# Problem: st_simplify returns POLYGON and MULTIPOLYGON results, affecting plotting
# Cast into a single geometry type to resolve this
nz_simple_poly = st_simplify(st_geometry(nz), dTolerance = 10000) |> 
  st_sfc() |> 
  st_cast("POLYGON")
nz_simple_multipoly = st_simplify(st_geometry(nz), dTolerance = 10000) |> 
  st_sfc() |> 
  st_cast("MULTIPOLYGON")
plot(nz_simple_poly)
length(nz_simple_poly)
nrow(nz)
```

E2. W pierwszym ćwiczeniu w rozdziale Operacje na danych przestrzennych ustalono, że region Canterbury ma 70 z 101 najwyższych punktów w Nowej Zelandii.
Korzystając z`st_buffer()`, ile punktów w`nz_height`znajduje się w odległości 100 km od Canterbury?

```{r 05-ex-e2}
canterbury = nz[nz$Name == "Canterbury", ]
cant_buff = st_buffer(canterbury, 100000)
nz_height_near_cant = nz_height[cant_buff, ]
nrow(nz_height_near_cant) # 75 - 5 more
```

E3. Znajdź geograficzny środek ciężkości Nowej Zelandii.
Jak daleko znajduje się on od środka ciężkości regionu Canterbury?

```{r 05-ex-e3}
cant_cent = st_centroid(canterbury)
nz_centre = st_centroid(st_union(nz))
st_distance(cant_cent, nz_centre) # 234 km
```

E4. Większość map świata ma orientację północną.
Mapę świata z orientacją południową można utworzyć poprzez odbicie (jedno z przekształceń afinicznych nie wspomnianych w tym rozdziale)geometriiobiektu`world`.
Napisz kod, aby to zrobić.
Wskazówka:do tego przekształceniamożesz użyćfunkcji`rotation()`z tego rozdziału.
Dodatkowo: utwórz odwróconą mapę swojego kraju.

```{r 05-ex-e4}
rotation = function(a){
  r = a * pi / 180 #degrees to radians
  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)
} 

world_sfc = st_geometry(world)
world_sfc_mirror = world_sfc * rotation(180)
plot(world_sfc)
plot(world_sfc_mirror)

us_states_sfc = st_geometry(us_states)
us_states_sfc_mirror = us_states_sfc * rotation(180)
plot(us_states_sfc)
plot(us_states_sfc_mirror)
```

E5. Uruchom kod z sekcji[5\.2.6](https://r.geocompx.org/geometry-operations.html#subsetting-and-clipping). Odwołując się do obiektów utworzonych w tej sekcji, wybierz podzbiór punktów z`p`, które znajdują się w obszarze`x`*i*`y`.

- Użyj podstawowych operatorów tworzenia podzbiorów.
- Użyj obiektu pośredniego utworzonego za pomocą`st_intersection()`\\index{vector!intersection}.

```{r 05-ex-e5a, echo=FALSE}
b = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # create 2 points
b = st_buffer(b, dist = 1) # convert points to circles
x = b[1]
y = b[2]
bb = st_bbox(st_union(x, y))
box = st_as_sfc(bb)
set.seed(2017)
p = st_sample(x = box, size = 10)
```

```{r 05-ex-e5}
p_in_y = p[y]
p_in_xy = p_in_y[x]
x_and_y = st_intersection(x, y)
p[x_and_y]
```

E6. Oblicz długość linii granicznych stanów USA w metrach.
Który stan ma najdłuższą granicę, a który najkrótszą?
Wskazówka:funkcja`st_length`oblicza długośćgeometrii`LINESTRING`lub`MULTILINESTRING`.

```{r 05-ex-e6}
us_states9311 = st_transform(us_states, "EPSG:9311")
us_states_bor = st_cast(us_states9311, "MULTILINESTRING")
us_states_bor$borders = st_length(us_states_bor)
arrange(us_states_bor, borders)
arrange(us_states_bor, -borders)
```

E7. Wczytaj plik srtm.tif do programu R (`srtm = rast(system.file("raster/srtm.tif", package = "spDataLarge"))`).
Ten raster ma rozdzielczość 0,00083 \* 0,00083 stopnia.
Zmień jego rozdzielczość na 0,01 \* 0,01 stopnia, korzystając ze wszystkich metod dostępnych wpakiecie**terra**.
Wizualizuj wyniki.
Czy zauważasz jakieś różnice między wynikami tych metod ponownego próbkowania?

```{r 05-ex-e7}
srtm = rast(system.file("raster/srtm.tif", package = "spDataLarge"))
rast_template = rast(ext(srtm), res = 0.01)
srtm_resampl1 = resample(srtm, y = rast_template, method = "bilinear")
srtm_resampl2 = resample(srtm, y = rast_template, method = "near")
srtm_resampl3 = resample(srtm, y = rast_template, method = "cubic")
srtm_resampl4 = resample(srtm, y = rast_template, method = "cubicspline")
srtm_resampl5 = resample(srtm, y = rast_template, method = "lanczos")

srtm_resampl_all = c(srtm_resampl1, srtm_resampl2, srtm_resampl3,
                     srtm_resampl4, srtm_resampl5)
plot(srtm_resampl_all)

# differences
plot(srtm_resampl_all - srtm_resampl1, range = c(-300, 300))
plot(srtm_resampl_all - srtm_resampl2, range = c(-300, 300))
plot(srtm_resampl_all - srtm_resampl3, range = c(-300, 300))
plot(srtm_resampl_all - srtm_resampl4, range = c(-300, 300))
plot(srtm_resampl_all - srtm_resampl5, range = c(-300, 300))
```


