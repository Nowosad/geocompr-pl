# Interakcje między danymi rastrowymi a wektorowymi{#raster-vector}

```{r, include=FALSE}
source("code/before_script.R")
```

## Wymagania wstępne{.unnumbered}

- W niniejszym rozdziale wymagane są następujące pakiety:

```{r 06-raster-vector-1, message=FALSE}
library(sf)
library(terra)
library(dplyr)
```

## Wprowadzenie

\\index{raster-vector interactions}
Niniejszy rozdział skupia się na interakcjach między rastrowymi i wektorowymi modelami danych geograficznych, przedstawionymi w rozdziale @ref(klasa-przestrzenna).
Obejmuje on kilka głównych technik:przycinanie i
maskowanie rastrowe przy użyciu obiektów wektorowych (sekcja @ref(przycinanie-rasterowe)),
wyodrębnianie wartości rastrowych przy użyciu różnych typów danych wektorowych (sekcja @ref(wyodrębnianie-rasterowe))oraz
konwersję rastrowo-wektorową (sekcje @ref(rasteryzacja) i @ref(wektorizacja-przestrzenna)).
Powyższe koncepcje zostały zilustrowane przy użyciu danych z poprzednich rozdziałów, aby zrozumieć ich potencjalne zastosowania w praktyce.

## Przycinanie rastrowe

\\index{raster!cropping}
Wiele projektów dotyczących danych geograficznych wymaga integracji danych z wielu różnych źródeł, takich jak obrazy teledetekcyjne (rastery) i granice administracyjne (wektory).
Często zakres wprowadzanych zestawów danych rastrowych jest większy niż obszar zainteresowania.
W takim przypadku**przycinanie**i**maskowanie**rastrasą przydatne do ujednolicenia zasięgu przestrzennego danych wejściowych.
Obie operacje zmniejszają zużycie pamięci obiektowej i związane z tym zasoby obliczeniowe dla kolejnych etapów analizy i mogą być niezbędnym etapem wstępnego przetwarzania podczas tworzenia atrakcyjnych map zawierających dane rastrowe.

Do zilustrowania przycinania rastra użyjemy dwóch obiektów:

- Obiekt`srtm``SpatRaster`reprezentujący wysokość (w metrach nad poziomem morza) w południowo-zachodniej części stanu Utah
- Obiektwektorowy`zion`(`sf`)reprezentujący Park Narodowy Zion

Zarówno obiekt docelowy, jak i obiekt przycinający muszą mieć tę samą projekcję.
Poniższy fragment kodu nie tylko odczytuje zestawy danych zpakietu**spDataLarge**zainstalowanego w rozdziale @ref(spatial-class), ale także „przekształca”`zion`(temat omówiony w rozdziale @ref(reproj-geo-data)):

```{r 06-raster-vector-2, results="hide"}
srtm = rast(system.file("raster/srtm.tif", package = "spDataLarge"))
zion = read_sf(system.file("vector/zion.gpkg", package = "spDataLarge"))
zion = st_transform(zion, st_crs(srtm))
```

Używamy`crop()`zpakietu**terra**do przycinania  rastera`srtm`.
Funkcja zmniejsza prostokątny zasięg obiektu przekazanego do jej pierwszego argumentu w oparciu o zasięg obiektu przekazanego do jej drugiego argumentu.
Funkcjonalność ta została zademonstrowana w poniższym poleceniu, które generuje rysunek @ref(fig:cropmask)(B).

```{r 06-raster-vector-3}
srtm_cropped = crop(srtm, zion)
```

\\index{raster!masking}
Związana z`crop()`jestfunkcja**terra**`mask()`, która ustawia wartości poza granicami obiektu przekazanego do jej drugiego argumentu na`NA`.Poniższe
polecenie maskuje zatem każdą komórkę poza granicami Parku Narodowego Zion (rysunek @ref(fig:cropmask)(C)).

```{r 06-raster-vector-4}
srtm_masked = mask(srtm, zion)
```

Co ważne,w większości przypadkówchcemy używać zarówno`crop()`jak i`mask()`razem.
Ta kombinacja funkcji (a) ograniczyłaby zasięg rastra do obszaru nas interesującego, a następnie (b) zastąpiłaby wszystkie wartości poza tym obszarem wartością NA.^\[Te dwie operacje można połączyć w jeden krok za`terra::crop(srtm, zion, mask = TRUE)`pomocą, ale dla przejrzystości wolimy je rozdzielić.\]

```{r 06-raster-vector-5}
srtm_cropped = crop(srtm, zion)
srtm_final = mask(srtm_cropped, zion)
```

Zmiana ustawień`mask()`daje różne wyniki.
Ustawienie`inverse = TRUE`maskuje wszystko*w*granicach parku (szczegóły w`?mask`) (rysunek @ref(fig:cropmask)(D)), natomiast ustawienie`updatevalue = 0`ustawia wszystkie piksele poza parkiem narodowym na 0.

```{r 06-raster-vector-6}
srtm_inv_masked = mask(srtm, zion, inverse = TRUE)
```

```{r cropmask, echo=FALSE, fig.cap="Raster cropping and raster masking.", fig.asp=0.36, fig.width=10, warning=FALSE}
#| message: FALSE
#| results: hide
library(tmap)
library(rcartocolor)
terrain_colors = carto_pal(7, "Geyser")
pz1 = tm_shape(srtm) + 
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors)) +
  tm_shape(zion) + 
  tm_borders(lwd = 2) + 
  tm_title("A. Original") +
  tm_layout(legend.show = FALSE)
pz2 = tm_shape(srtm_cropped) +
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors)) +
  tm_shape(zion) +
  tm_borders(lwd = 2) + 
  tm_title("B. Crop") +
  tm_layout(legend.show = FALSE)
pz3 = tm_shape(srtm_masked) + 
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors)) +
  tm_shape(zion) + 
  tm_borders(lwd = 2) + 
  tm_title("C. Mask") +
  tm_layout(legend.show = FALSE)
pz4 = tm_shape(srtm_inv_masked) +
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors)) +
  tm_shape(zion) +
  tm_borders(lwd = 2) + 
  tm_title("D. Inverse mask") +
  tm_layout(legend.show = FALSE)
tmap_arrange(pz1, pz2, pz3, pz4, ncol = 4, asp = NA)
```

## Ekstrakcja rastra

\\index{raster!extraction}
Ekstrakcja rastra to proces identyfikacji i zwracania wartości powiązanych z rastrem „docelowym” w określonych lokalizacjach, w oparciu o obiekt „selektora” geograficznego (zazwyczaj wektorowego).
Wyniki zależą od typu użytego selektora (punkty, linie lub wielokąty) oraz argumentów przekazanych dofunkcji`terra::extract()`.
Odwrotnością ekstrakcji rastrowej — przypisywaniem wartości komórek rastra na podstawie obiektów wektorowych — jest rasteryzacja, opisana w sekcji @ref(rasterization).

\\index{raster!extraction points}
Podstawowym przykładem jest ekstrakcja wartości komórki rastra w określonych**punktach**.
W tym celu użyjemy`zion_points`, które zawierają próbkę 30 lokalizacji w Parku Narodowym Zion (rysunek @ref(fig:pointextr)).
Poniższe polecenie wyodrębnia wartości wysokości z`srtm`i tworzy ramkę danych z identyfikatorami punktów (jedna wartość na wiersz wektora) i powiązanymi`srtm`wartościami  dla każdego punktu.
Teraz możemy dodać wynikowy obiekt do naszego`zion_points`zestawu danych za pomocą`cbind()`funkcji  :

```{r 06-raster-vector-8}
data("zion_points", package = "spDataLarge")
elevation = terra::extract(srtm, zion_points)
zion_points = cbind(zion_points, elevation)
```

```{r 06-raster-vector-9, echo=FALSE, eval=FALSE}
library(dplyr)
zion_points2 = zion_points
zion_points2$a = 1
zion_points2 = zion_points2 |> group_by(a) |> summarise()
elevation = terra::extract(srtm, zion_points2)
zion_points = cbind(zion_points, elevation)
```

```{r pointextr, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Locations of points used for raster extraction.", fig.asp=0.67}
source("code/06-pointextr.R", print.eval = TRUE)
```

\\index{raster!extraction lines}
Ekstrakcja rastra działa również zselektorami**linii**.
Następnie wyodrębnia jedną wartość dla każdej komórki rastra dotkniętej linią.
Jednak podejście oparte na ekstrakcji linii nie jest zalecane do uzyskania wartości wzdłuż transektów, ponieważ trudno jest uzyskać prawidłową odległość między każdą parą wyodrębnionych wartości rastra.

W tym przypadku lepszym podejściem jest podzielenie linii na wiele punktów, a następnie wyodrębnienie wartości dla tych punktów.
Aby to zademonstrować, poniższy kod tworzy`zion_transect`, prostą linię biegnącą od północnego zachodu do południowego wschodu Parku Narodowego Zion, zilustrowaną na rysunku @ref(fig:lineextr)(A) (podsumowanie modelu danych wektorowych znajduje się w sekcji @ref(vector-data)):

```{r 06-raster-vector-11}
zion_transect = cbind(c(-113.2, -112.9), c(37.45, 37.2)) |>
  st_linestring() |> 
  st_sfc(crs = crs(srtm)) |>
  st_sf(geometry = _)
```

```{r 06-raster-vector-12, eval=FALSE, echo=FALSE}
# Aim: show how extraction works with non-straight lines by
# using this alternative line object:
zion_transect2 = cbind(c(-113.2, -112.9, -113.2), c(36.45, 37.2, 37.5)) |>
  st_linestring() |> 
  st_sfc(crs = crs(srtm)) |>
  st_sf()
zion_transect = rbind(zion_transect, zion_transect2)
```

Przydatność wyodrębniania wysokości z selektora liniowego można zilustrować, wyobrażając sobie, że planujesz wycieczkę pieszą.Przedstawiona
poniżej metoda zapewnia „profil wysokościowy” trasy (linia nie musi być prosta), przydatny do oszacowania czasu trwania wycieczki ze względu na długie podjazdy.

Pierwszym krokiem jest dodanie unikalnego`id`dla każdego przekroju.
Następnie za pomocą`st_segmentize()`funkcji  możemy dodać punkty wzdłuż naszych linii o podanej gęstości (`dfMaxLength`) i przekształcić je w punkty za`st_cast()`pomocą.

```{r 06-raster-vector-13, warning=FALSE}
zion_transect$id = 1:nrow(zion_transect)
zion_transect = st_segmentize(zion_transect, dfMaxLength = 250)
zion_transect = st_cast(zion_transect, "POINT")
```

Teraz mamy duży zbiór punktów i chcemy wyznaczyć odległość między pierwszym punktem w naszych przekrojach a każdym z kolejnych punktów.
W tym przypadku mamy tylko jeden transekt, ale kod powinien zasadniczo działać dla dowolnej liczby transektów:

```{r 06-raster-vector-14}
zion_transect = zion_transect |> 
  group_by(id) |> 
  mutate(dist = st_distance(geometry)[, 1]) 
```

Na koniec możemy wyodrębnić wartości wysokości dla każdego punktu w naszych transektach i połączyć te informacje z naszym głównym obiektem.

```{r 06-raster-vector-15}
zion_elev = terra::extract(srtm, zion_transect)
zion_transect = cbind(zion_transect, zion_elev)
```

Wynikowy`zion_transect`może być użyty do stworzenia profili wysokościowych, jak pokazano na rysunku @ref(fig:lineextr)(B).

```{r lineextr, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Location of a line used for (A) raster extraction and (B) the elevation along this line.", fig.scap="Line-based raster extraction."}
library(tmap)
library(grid)
library(ggplot2)

zion_transect_line = cbind(c(-113.2, -112.9), c(37.45, 37.2)) |>
  st_linestring() |> 
  st_sfc(crs = crs(srtm)) |> 
  st_sf()

zion_transect_points = st_cast(zion_transect, "POINT")[c(1, nrow(zion_transect)), ]
zion_transect_points$name = c("start", "end")

rast_poly_line = tm_shape(srtm) +
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors),
            col.legend = tm_legend("Elevation (m)")) + 
  tm_shape(zion) +
  tm_borders(lwd = 2) + 
  tm_shape(zion_transect_line) + 
  tm_lines(col = "black", lwd = 4) + 
  tm_shape(zion_transect_points) +   
  tm_text("name", 
          text.scale = tm_scale(bg.color = "white", bg.alpha = 0.75, auto.placement = TRUE)) +
  tm_layout(legend.frame = TRUE, legend.position = c("RIGHT", "TOP"),
            legend.bg.color = "white")

plot_transect = ggplot(zion_transect, aes(as.numeric(dist), srtm)) + 
  geom_line() +
  labs(x = "Distance (m)", y = "Elevation (m a.s.l.)") + 
  theme_bw() +
  # facet_wrap(~id) +
  theme(plot.margin = unit(c(5.5, 15.5, 5.5, 5.5), "pt"))

grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2, heights = unit(c(0.25, 5), "null"))))
grid.text("A. Line extraction", vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("B. Elevation along the line", vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
print(rast_poly_line, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(plot_transect, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
```

\\index{raster!extraction polygons}
Ostatnim typem obiektu wektorowego do ekstrakcji rastrowej są**wielokąty**.
Podobnie jak linie, wielokąty zwykle zwracają wiele wartości rastrowych na wielokąt.Pokazuje
to poniższe polecenie, które generuje ramkę danych z nazwami kolumn`ID`(numer wiersza wielokąta) i`srtm`(powiązane wartości wysokości):

Wyniki

```{r 06-raster-vector-17, eval=FALSE, echo=FALSE}
# aim: create zion_many to test multi-polygon results
n = 3
zion_many = st_sample(x = zion, size = n) |> 
  st_buffer(dist = 500) |>
  st_sf(data.frame(v = 1:n), geometry = _)
plot(zion_many)

# for continuous data:
zion_srtm_values1 = terra::extract(x = srtm, y = zion_many, fun = min)
zion_srtm_values2 = terra::extract(x = srtm, y = zion_many, fun = mean)
zion_srtm_values3 = terra::extract(x = srtm, y = zion_many, fun = max)

# for categories
nlcd = rast(system.file("raster/nlcd.tif", package = "spDataLarge"))
zion_many2 = st_transform(zion_many, st_crs(nlcd))
zion_nlcd = terra::extract(nlcd, zion_many2)
count(zion_nlcd, levels)
```

```{r 06-raster-vector-18}
zion_srtm_values = terra::extract(x = srtm, y = zion)
```

takie można wykorzystać do generowania statystyk podsumowujących dla wartości rastrowych na wielokąt, na przykład w celu scharakteryzowania pojedynczego regionu lub porównania wielu regionów.
Pokazuje to poniższy kod, który tworzy obiekt`zion_srtm_df`zawierający statystyki podsumowujące dla wartości wysokości w Parku Narodowym Zion (patrz rysunek @ref(fig:polyextr)(A)):

```{r 06-raster-vector-19}
group_by(zion_srtm_values, ID) |> 
  summarize(across(srtm, list(min = min, mean = mean, max = max)))
```

W powyższym fragmencie kodu użyto**dplyr**\\index{dplyr (package)}do dostarczenia statystyk podsumowujących dla wartości komórek na identyfikator wielokąta, jak opisano w rozdziale @ref(attr).
Wyniki dostarczają przydatnych podsumowań, na przykład, że maksymalna wysokość w parku wynosi około 2661 metrów nad poziomem morza (w ten sposób można również obliczyć inne statystyki podsumowujące, takie jak odchylenie standardowe).
Ponieważ w przykładzie występuje tylko jeden wielokąt, zwracana jest ramka danych z jednym wierszem; jednak metoda ta działa również w przypadku użycia wielu wielokątów selekcyjnych.

Podobne podejście sprawdza się w przypadku zliczania wystąpień wartości rastrowych kategorii w wielokątach.
Zostało to zilustrowane na przykładzie zbioru danych dotyczących pokrycia terenu (`nlcd`) zpakietu**spDataLarge**na rysunku @ref(fig:polyextr)(B) i pokazane w poniższym kodzie:

```{r 06-raster-vector-20, warning=FALSE, message=FALSE}
nlcd = rast(system.file("raster/nlcd.tif", package = "spDataLarge"))
zion2 = st_transform(zion, st_crs(nlcd))
zion_nlcd = terra::extract(nlcd, zion2)
zion_nlcd |> 
  group_by(ID, levels) |>
  count()
```

```{r polyextr, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Area used for (A) continuous and (B) categorical raster extraction.", fig.width=7.5}
rast_poly_srtm = tm_shape(srtm) + 
  tm_raster(col.scale = tm_scale_continuous(values = terrain_colors),
            col.legend = tm_legend("Elevation (m)")) + 
  tm_shape(zion) +
  tm_polygons(lwd = 2, fill_alpha = 0.3) +
  tm_title("A. Continuous data extraction") +
  tm_layout(legend.frame = TRUE, legend.position = c("LEFT", "BOTTOM"),
            legend.bg.color = "white")
rast_poly_nlcd = tm_shape(nlcd) +
  tm_raster(col.scale = tm_scale_categorical(levels.drop = TRUE),
            col.legend = tm_legend(title = "Land cover")) + 
  # tm_raster(drop.levels = TRUE, title = "Land cover", legend.show = TRUE) + 
  tm_shape(zion) +
  tm_polygons(lwd = 2, fill_alpha = 0.3)  +
  tm_title("B. Categorical data extraction") +
  tm_layout(legend.frame = TRUE, legend.position = c("LEFT", "BOTTOM"),
            legend.bg.color = "white")
tmap_arrange(rast_poly_srtm, rast_poly_nlcd, ncol = 2)
```

\\index{raster!extraction fractions}
Chociażpakiet**terra**umożliwia szybkie wyodrębnianie wartości rastrowych z wielokątów,nadal`extract()`może stanowić wąskie gardło podczas przetwarzania dużych zbiorów danych wielokątów.
Pakiet**exactextractr**oferuje[znacznie szybszą alternatywę](https://github.com/geocompx/geocompr/issues/813)dla wyodrębniania wartości pikseli za pomocą`exact_extract()`funkcji .
Funkcja`exact_extract()`domyślnie oblicza również ułamek każdej komórki rastrowej pokrywającej się z wielokątem, co jest bardziej precyzyjne (szczegóły w uwadze poniżej).

```{block2 06-raster-vector-22, type="rmdnote"}
Polygons usually have irregular shapes, and, therefore, a polygon can overlap only some parts of a raster's cells. 
To get more detailed results, the `terra::extract()` function has an argument called `exact`. 
With `exact = TRUE`, we get one more column `fraction` in the output data frame, which represents a fraction of each cell that is covered by the polygon.
This could be useful to calculate, for example, a weighted mean for continuous rasters or more precise coverage for categorical rasters.
By default, it is `FALSE`, as this operation requires more computations. 
The `exactextractr::exact_extract()` function always computes the coverage fraction of the polygon in each cell.
```

```{r 06-raster-vector-23, include=FALSE}
zion_srtm_values = terra::extract(x = srtm, y = zion, exact = FALSE)
```

## Rasteryzacja{#rasterization}

\\index{rasterization}
Rasteryzacja to konwersja obiektów wektorowych na ich reprezentację w postaci obiektów rastrowych.
Zazwyczaj wynikowy raster jest następnie wykorzystywany do analizy ilościowej (np. analizy terenu) lub modelowania.
Jak widzieliśmy w rozdziale @ref(spatial-class), model danych rastrowych ma pewne cechy,które sprawiają, że sprzyja on stosowaniu określonych metod.
Ponadto proces rasteryzacji może pomóc w uproszczeniu zbiorów danych, ponieważ wszystkie uzyskane wartości mają tę samą rozdzielczość przestrzenną: rasteryzację można postrzegać jako specjalny rodzaj agregacji danych geograficznych.

Pakiet**terra**zawiera funkcję`rasterize()`służącą do wykonywania tej czynności.
Jej pierwsze dwa argumenty to ,obiekt wektorowy,`x`który ma zostać zrasteryzowany, oraz,`y`obiekt „szablonu rastra” definiujący zasięg, rozdzielczość i CRS danych wyjściowych.
Rozdzielczość geograficzna rastru wejściowego ma duży wpływ na wyniki: jeśli jest zbyt niska (rozmiar komórki jest zbyt duży), wynik może nie odzwierciedlać pełnej zmienności geograficznej danych wektorowych; jeśli jest zbyt wysoka, czas obliczeń może być nadmierny.
Nie ma prostych zasad, którymi można się kierować przy podejmowaniu decyzji o odpowiedniej rozdzielczości geograficznej, która w dużym stopniu zależy od przeznaczenia wyników.
Często rozdzielczość docelowa jest narzucana użytkownikowi, na przykład gdy wynik rasteryzacji musi być dostosowany do innego istniejącego rastra.

indeks{rasterization!points}
Aby zademonstrować działanie rasteryzacji, użyjemy szablonu rastra, który ma taki sam zasięg i CRS jak dane wektorowe`cycle_hire_osm_projected`wejściowe(zbiór danych dotyczących punktów wypożyczania rowerów w Londynie przedstawiono na rysunku @ref(fig:vector-rasterization1)(A)) oraz rozdzielczość przestrzenną 1000 metrów:

```{r 06-raster-vector-24}
cycle_hire_osm = spData::cycle_hire_osm
cycle_hire_osm_projected = st_transform(cycle_hire_osm, "EPSG:27700")
raster_template = rast(ext(cycle_hire_osm_projected), resolution = 1000,
                       crs = crs(cycle_hire_osm_projected))
```

Rasteryzacja jest operacją bardzo elastyczną: wyniki zależą nie tylko od charakteru szablonu rastra, ale także od typu wektora wejściowego (np. punkty, wielokąty) i różnych argumentów przyjmowanych przezfunkcję`rasterize()`.

Aby zilustrować tę elastyczność, wypróbujemy trzy różne podejścia do rasteryzacji.
Najpierw utworzymy raster reprezentujący obecność lub brak punktów wypożyczania rowerów (znany jako raster obecności/braku).
W tym przypadku`rasterize()`nie wymaga żadnych dodatkowych argumentów poza`x`i`y`, wspomnianymi wcześniej obiektami wektorowymi i rastrowymi (wyniki przedstawiono na rysunku @ref(fig:vector-rasterization1)(B)).

```{r 06-raster-vector-25}
ch_raster1 = rasterize(cycle_hire_osm_projected, raster_template)
```

Argument`fun`określa statystyki podsumowujące używane do konwersji wielu obserwacji znajdujących się blisko siebie na powiązane komórki w obiekcie rastrowym.
Domyślnieużywane`fun = "last"`jest , alemożna użyćinnych`fun = "length"`opcji,takich jak, w tym przypadku do zliczenia liczby punktów wypożyczania rowerów w każdej komórce siatki (wyniki tej operacji przedstawiono na rysunku @ref(fig:vector-rasterization1)(C)).

```{r 06-raster-vector-26}
ch_raster2 = rasterize(cycle_hire_osm_projected, raster_template, 
                       fun = "length")
```

Nowe dane wyjściowe,`ch_raster2`, pokazują liczbę punktów wypożyczania rowerów w każdej komórce siatki.
Lokalizacje wypożyczalni rowerów mają różną liczbę rowerów opisaną przezzmienną`capacity`, co rodzi pytanie, jaka jest pojemność każdej komórki siatki?
Aby to obliczyć, musimy`sum`pole (`"capacity"`), co daje wynik przedstawiony na rysunku @ref(fig:vector-rasterization1)(D), obliczony za pomocą następującego polecenia (można użyćinnych funkcji`mean`podsumowujących, takich jak).

```{r 06-raster-vector-27}
ch_raster3 = rasterize(cycle_hire_osm_projected, raster_template, 
                       field = "capacity", fun = sum, na.rm = TRUE)
```

```{r vector-rasterization1, echo=FALSE, fig.cap="Examples of point rasterization.", warning=FALSE, message=FALSE}
source("code/06-vector-rasterization1.R", print.eval = TRUE)
```

\\index{rasterization!lines}
\\index{rasterization!polygons}
Inny zbiór danych oparty na wielokątach i granicach Kalifornii (utworzony poniżej) ilustruje rasteryzację linii.
Po przekształceniu obiektów wielokątów w ciąg wieloliniowy tworzony jest szablon rastra o rozdzielczości 0,5 stopnia:

```{r 06-raster-vector-29}
california = dplyr::filter(us_states, NAME == "California")
california_borders = st_cast(california, "MULTILINESTRING")
raster_template2 = rast(ext(california), resolution = 0.5,
                        crs = st_crs(california)$wkt)
```

Przy rozważaniu rasteryzacji linii lub wielokątów przydatnym dodatkowym argumentem jest`touches`.
Domyślnie jest to`FALSE`, ale po zmianie nawszystkie komórki, które stykają`TRUE`się z linią lub granicą wielokąta, otrzymują wartość.
Rasteryzacja linii z`touches = TRUE`jest pokazana w poniższym kodzie (rysunek @ref(fig:vector-rasterization2)(A)).

```{r 06-raster-vector-30}
california_raster1 = rasterize(california_borders, raster_template2,
                               touches = TRUE)
```

Porównaj to z rasteryzacją wielokąta, z`touches = FALSE`domyślnie, która wybiera tylko komórki rastrowe, których środki ciężkości znajdują się wewnątrz wielokąta selektora, jak pokazano na rysunku @ref(fig:vector-rasterization2)(B).

## Wektorizacja

```{r 06-raster-vector-31}
california_raster2 = rasterize(california, raster_template2) 
```

```{r vector-rasterization2, echo=FALSE, fig.cap="Examples of line and polygon rasterizations.", warning=FALSE, message=FALSE}
source("code/06-vector-rasterization2.R", print.eval = TRUE)
```

## przestrzenna

\\indexWektorizacja{spatial vectorization}
przestrzenna jest odpowiednikiem rasteryzacji (sekcja @ref(rasterization)), ale w przeciwnym kierunku.
Polega ona na przekształceniu danych rastrowych ciągłych przestrzennie w dane wektorowe dyskretne przestrzennie

,

takie jak punkty,

{spatial vectorization!points}


linie lub wielokąty.

```{block2 06-raster-vector-33, type="rmdnote"}
Be careful with the wording!
In R, vectorization usually refers to the possibility of replacing `for`-loops and alike by doing things like `1:10 / 2` (see also @wickham_advanced_2019).
```

Najprostszą formą wektoryzacji jest przekształcenie centroidów komórek rastrowe w punkty.
`as.points()`robi dokładnie to dla wszystkichkomórek siatkiniebędących`NA`komórkamirastrowymi (rysunek @ref(fig:raster-vectorization1)).
Należy zauważyć, że w tym przypadku użyliśmy`st_as_sf()`równieżdo konwersji wynikowego obiektu doklasy`sf`.

```{r 06-raster-vector-34}
elev = rast(system.file("raster/elev.tif", package = "spData"))
elev_point = as.points(elev) |> 
  st_as_sf()
```

```{r raster-vectorization1, echo=FALSE, fig.cap="Raster and point representation of the elev object.", warning=FALSE}
source("code/06-raster-vectorization1.R", print.eval = TRUE)
```

\\index{spatial vectorization!contours}
Innym popularnym rodzajem wektoryzacji przestrzennej jest tworzenie linii konturowych reprezentujących na przykład linie ciągłej wysokości lub temperatury (izotermy).
Użyjemy rzeczywistego cyfrowego modelu wysokościowego (DEM), ponieważ sztuczny raster`elev`tworzy linie równoległe (zadanie dla czytelnika: sprawdź to i wyjaśnij, dlaczego tak się dzieje).Linie
konturowe można utworzyć za pomocąfunkcji**terra**, która sama w sobie jest`as.contour()`opakowaniem wbudowanej funkcji R`filled.contour()`, jak pokazano poniżej (nie pokazano):

```{r 06-raster-vector-36, eval=FALSE}
dem = rast(system.file("raster/dem.tif", package = "spDataLarge"))
cl = as.contour(dem) |> 
  st_as_sf()
plot(dem, axes = FALSE)
plot(cl, add = TRUE)
```

Kontury można również dodawać do istniejących wykresów za pomocą funkcji takich jak`contour()`,`rasterVis::contourplot()`.

<!-- lub `tmap::tm_iso()` (jeszcze nie zaimplementowane na dzień 24.11.2023 r.) -->

Jak pokazano na rysunku @ref(fig:contour-tmap), izolinie można opisywać.

\\index{hillshade}

```{r contour-tmap, echo=FALSE, message=FALSE, fig.cap="Digital elevation model with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.", fig.scap="DEM with hillshading.", warning=FALSE, fig.asp=0.56, fig.width=3.5}
# hs = shade(slope = terrain(dem, "slope", unit = "radians"),
#            aspect = terrain(dem, "aspect", unit = "radians"))
# plot(hs, col = gray(0:100 / 100), legend = FALSE)
# # overlay with DEM
# plot(dem, col = terrain.colors(25), alpha = 0.5, legend = FALSE, add = TRUE)
# # add contour lines
# contour(dem, col = "white", add = TRUE)
knitr::include_graphics("images/06-contour-tmap.png")
```

\\index{spatial vectorization!polygons}
Ostatni rodzaj wektoryzacji polega na konwersji rastrów na wielokąty.
Można to zrobić za`terra::as.polygons()`pomocą, która konwertuje każdą komórkę rastra na wielokąt składający się z pięciu współrzędnych, z których wszystkie są przechowywane w pamięci (co wyjaśnia, dlaczego rastrowe pliki są często szybsze w porównaniu z wektorowymi!).

Ilustruje to poniższy przykład, w którym`grain`obiektzostał przekształconyw wielokąty, a następnie zlikwidowano granice między wielokątami o tych samych wartościach atrybutów (zobacz równieżargument`dissolve`  w`as.polygons()`).

```{r 06-raster-vector-39}
grain = rast(system.file("raster/grain.tif", package = "spData"))
grain_poly = as.polygons(grain) |> 
  st_as_sf()
```

```{r 06-raster-vector-40, echo=FALSE, fig.cap="Vectorization of (A) raster into (B) polygons (dissolve = FALSE) and aggregated polygons (dissolve = TRUE).", warning=FALSE, message=FALSE, fig.asp=0.4, fig.scap="Vectorization."}
source("code/06-raster-vectorization2.R", print.eval = TRUE)
```

Zagregowane wielokąty zbioru`grain`danych mają prostoliniowe granice, które wynikają z połączenia pikseli prostokątnych.
Pakiet**smoothr**opisany w rozdziale @ref(geometry-operations) może być użyty do wygładzenia krawędzi wielokątów.
Ponieważ wygładzanie usuwa ostre krawędzie w granicach wielokątów, wygładzone wielokąty nie będą miały dokładnie takiego samego pokrycia przestrzennego jak oryginalne piksele.Należy
zatem zachować ostrożność podczas wykorzystywania wygładzonych wielokątów do dalszej analizy.

## Ćwiczenia

```{r, echo=FALSE, results="asis"}
res = knitr::knit_child('_06-ex.Rmd', quiet = TRUE, options = list(include = FALSE, eval = FALSE))
cat(res, sep = '\n')
```


